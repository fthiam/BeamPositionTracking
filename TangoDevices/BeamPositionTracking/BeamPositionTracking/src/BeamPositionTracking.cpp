static const char *RcsId = "$Id:  $";
//+=============================================================================
//
// file :         BeamPositionTracking.cpp
//
// description :  C++ source for the BeamPositionTracking and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                BeamPositionTracking are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  Thiam F.
//
// $Revision:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source:  $
// $Log:  $
//
// copyleft :    Synchrotron SOLEIL 
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name               |  Method name
//	----------------------------------------
//  State                      |  dev_state()
//  Status                     |  dev_status()
//  ActuatorSystemCalibration  |  actuator_system_calibration()
//  StartBeamTracking          |  start_beam_tracking()
//  StopBeamTracking           |  stop_beam_tracking()
//  AcknowlegeStep             |  acknowlege_step()
//
//===================================================================


#include <tango.h>
#include <BeamPositionTracking.h>
#include <BeamPositionTrackingClass.h>
#include <yat/utils/StringTokenizer.h>

// Token separator for PS property.
#define kTOKEN_SEPARATOR std::string("::")
//Simulated mode strings
#define SIMULATED_MODE std::string("SIMULATED")
#define NORMAL_MODE std::string("NORMAL")
namespace BeamPositionTracking_ns
{

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::BeamPositionTracking(string &s)
// 
// description : 	constructor for simulated BeamPositionTracking
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
BeamPositionTracking::BeamPositionTracking(Tango::DeviceClass *cl,string &s)
:Tango::Device_4Impl(cl,s.c_str())
{
	init_device();
}

BeamPositionTracking::BeamPositionTracking(Tango::DeviceClass *cl,const char *s)
:Tango::Device_4Impl(cl,s)
{
	init_device();
}

BeamPositionTracking::BeamPositionTracking(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_4Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::delete_device()
{
	//	Delete device allocated objects
	if (m_taskManager)
		delete m_taskManager;
	if (m_dynAttrManager)
		delete m_dynAttrManager;

	//- remove the DeviceInfo
   // yat4tango::DeviceInfo::release(this);
    //- remove the InnerAppender
   // yat4tango::InnerAppender::release(this);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::init_device()
{
	INFO_STREAM << "BeamPositionTracking::BeamPositionTracking() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	get_device_property();

	// Initialize Members
	m_initDone = false;
	m_computedTime = 0;
	m_taskManager = 0;
	m_dynAttrManager = 0;
	m_xBeamPosition = 0;
	m_yBeamPosition = 0;
	
	BPTTaskManager::PIDCoefficient xAxisPID;
	BPTTaskManager::PIDCoefficient yAxisPID;

	INFO_STREAM << "Create the InnerAppender in order to manage logs." << endl;
   	// yat4tango::InnerAppender::initialize(this, 512);

	INFO_STREAM << "Create the DeviceInfo in order to manage info on versions." << endl;
   	// yat4tango::DeviceInfo::initialize( this, YAT_XSTR(PROJECT_NAME), YAT_XSTR(PROJECT_VERSION));
    // yat4tango::DeviceInfo::add_dependency(this, "BeamPositionTracking ", YAT_XSTR(beamPositionPointing_PROJECT_VERSION));


	bool simulated_mode = false;
	//Simulated mode 
	if (deviceMode == NORMAL_MODE)
		simulated_mode = false;
	else
		simulated_mode = true;

	//Extract PIDs informations
	try{
		xAxisPID = extractPIDCoeffients(xPIDDefinition);
		yAxisPID = extractPIDCoeffients(yPIDDefinition);
	}catch(std::invalid_argument &iaE){
        set_status ("Initialization error [PID definition not correct, has to be written this way : 'true::1::2::3']");
        set_state (Tango::FAULT);
        return;
	}

	//Get axes aliases
	if (axesAliases.size() >= 2){
		m_xAxisAlias = axesAliases.at(0);
		m_yAxisAlias = axesAliases.at(1);

		setNewLabels(m_xAxisAlias, m_yAxisAlias);
	}

			
	//Construct fixed mode instructions using properties
	if (!initFixedModeValues()){
		std::string err_msg = "Initialization error [Check fixed mode values or set fixed mode to false]";
        ERROR_STREAM << err_msg << std::endl;
        set_status (err_msg);
        set_state (Tango::FAULT);
        return;
	}else{
		//init target and warning zone with fixed definitions 
		m_target.xTargetPoint = m_fixedModeDef.target.xTargetPoint;
		m_target.yTargetPoint = m_fixedModeDef.target.yTargetPoint;
		m_warningZone.xCenter = m_fixedModeDef.warningZone.xCenter;
		m_warningZone.yCenter = m_fixedModeDef.warningZone.yCenter;
		m_warningZone.radius = m_fixedModeDef.warningZone.radius;
	}
	
	// Creation of dynAttrManager
	try{
		if (!m_dynAttrManager)
			m_dynAttrManager = new yat4tango::DynamicAttributeManager(this);

	}catch( Tango::DevFailed& df ){
        ERROR_STREAM << df << std::endl;
        set_status ("Initialization error [Tango Exception caught while instantiating DynamicAttributeManager]");
        set_state (Tango::FAULT);
        return;
    }
    catch(...){
        std::string err_msg = "Initialization error [unknown exception caught while instantiating DynamicAttributeManager]";
        ERROR_STREAM << err_msg << std::endl;
        set_status (err_msg);
        set_state (Tango::FAULT);
        return;
    }

	// Creation of BPTTaskManager
	try{
		if (!m_taskManager)
			m_taskManager = new BPTTaskManager::BPTTaskManager(this, m_dynAttrManager, sensorPluginType, pluginPath, 
																	actuatorSystemDeviceAdress,
																	xAxisPID, yAxisPID,
																	calibrationStepNbXAxis, calibrationStepNbYAxis,
																	nbImgToAlign, deviceTaskPeriod, simulated_mode, m_fixedModeDef);


		//Init plug with attr in this thread.... since it's possible that the plugin has an attribute ???
		if (!m_taskManager->sensorPluginInitialisation()){
			set_status ("Initialization error [Tango Exception caught while instantiating BPTTaskManager]");
	        set_state (Tango::FAULT);
	        return;
		}


	}catch( Tango::DevFailed &df ){
        ERROR_STREAM << df << std::endl;
        set_status ("Initialization error [Tango Exception caught while instantiating BPTTaskManager]");
        set_state (Tango::FAULT);
        return;
    }
    catch(...){
        std::string err_msg = "Initialization error [unknown exception caught while instantiating BPTTaskManager]";
        ERROR_STREAM << err_msg << std::endl;
        set_status (err_msg);
        set_state (Tango::FAULT);
        return;
    }

    // Start BPTTaskManager
    try
    {
        if (m_taskManager)
			m_taskManager->go(3000);
		
        set_state(Tango::INIT);
        set_status("Device initialisation started...");
    }
    catch( Tango::DevFailed &df )
    {
        ERROR_STREAM << df << std::endl;
        set_status ("Initialization error [Tango Error: " +  std::string(df.errors[0].desc) + ", while starting BPTTaskManager]");
        set_state (Tango::FAULT);
        m_taskManager = NULL;
        return;
    }
    catch(...)
    {
        std::string err_msg = "Initialization error [Unknown Error while starting BPTTaskManager]";  
        ERROR_STREAM << err_msg << std::endl;
        set_status (err_msg);
        set_state (Tango::FAULT);
        m_taskManager = NULL;
        return;
    }


    setCentroidsUnits(m_taskManager->i_getSensorUnit());
    m_initDone = true;
}
//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::setCentroidsUnits
// 
// description : 	To set units on x/y AxisCurrentBeamPosition attributes
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::setCentroidsUnits(std::string sensorUnits){

	vector<string> vecCentroidsAttributes;
	Tango::DevVarStringArray dvsa_attribute;
    vecCentroidsAttributes.push_back("xAxisCurrentBeamPosition");
    vecCentroidsAttributes.push_back("yAxisCurrentBeamPosition");
	dvsa_attribute << vecCentroidsAttributes;
	Tango::AttributeConfigList* seq_conf;
    seq_conf = get_attribute_config(dvsa_attribute);

    (*seq_conf)[0].unit = sensorUnits.c_str();
    (*seq_conf)[1].unit = sensorUnits.c_str();
  	set_attribute_config((*seq_conf));
}


//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("DeviceTaskPeriod"));
	dev_prop.push_back(Tango::DbDatum("NbImgToAlign"));
	dev_prop.push_back(Tango::DbDatum("SensorPluginType"));
	dev_prop.push_back(Tango::DbDatum("ActuatorSystemDeviceAdress"));
	dev_prop.push_back(Tango::DbDatum("PluginPath"));
	dev_prop.push_back(Tango::DbDatum("CalibrationStepNbXAxis"));
	dev_prop.push_back(Tango::DbDatum("CalibrationStepNbYAxis"));
	dev_prop.push_back(Tango::DbDatum("XPIDDefinition"));
	dev_prop.push_back(Tango::DbDatum("YPIDDefinition"));
	dev_prop.push_back(Tango::DbDatum("DeviceMode"));
	dev_prop.push_back(Tango::DbDatum("FixedXTarget"));
	dev_prop.push_back(Tango::DbDatum("FixedYTarget"));
	dev_prop.push_back(Tango::DbDatum("FixedMode"));
	dev_prop.push_back(Tango::DbDatum("FixedXWarningZoneCenter"));
	dev_prop.push_back(Tango::DbDatum("FixedYWarningZoneCenter"));
	dev_prop.push_back(Tango::DbDatum("FixedWarningZoneRadius"));
	dev_prop.push_back(Tango::DbDatum("AxesAliases"));
	dev_prop.push_back(Tango::DbDatum("UI_xColdThreshold"));
	dev_prop.push_back(Tango::DbDatum("UI_xHotThreshold"));
	dev_prop.push_back(Tango::DbDatum("UI_yHotThreshold"));
	dev_prop.push_back(Tango::DbDatum("UI_yColdThreshold"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	BeamPositionTrackingClass	*ds_class =
		(static_cast<BeamPositionTrackingClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize DeviceTaskPeriod from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  deviceTaskPeriod;
	else {
		//	Try to initialize DeviceTaskPeriod from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  deviceTaskPeriod;
	}
	//	And try to extract DeviceTaskPeriod value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  deviceTaskPeriod;

	//	Try to initialize NbImgToAlign from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  nbImgToAlign;
	else {
		//	Try to initialize NbImgToAlign from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  nbImgToAlign;
	}
	//	And try to extract NbImgToAlign value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  nbImgToAlign;

	//	Try to initialize SensorPluginType from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sensorPluginType;
	else {
		//	Try to initialize SensorPluginType from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sensorPluginType;
	}
	//	And try to extract SensorPluginType value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sensorPluginType;

	//	Try to initialize ActuatorSystemDeviceAdress from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  actuatorSystemDeviceAdress;
	else {
		//	Try to initialize ActuatorSystemDeviceAdress from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  actuatorSystemDeviceAdress;
	}
	//	And try to extract ActuatorSystemDeviceAdress value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  actuatorSystemDeviceAdress;

	//	Try to initialize PluginPath from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  pluginPath;
	else {
		//	Try to initialize PluginPath from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  pluginPath;
	}
	//	And try to extract PluginPath value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pluginPath;

	//	Try to initialize CalibrationStepNbXAxis from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  calibrationStepNbXAxis;
	else {
		//	Try to initialize CalibrationStepNbXAxis from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  calibrationStepNbXAxis;
	}
	//	And try to extract CalibrationStepNbXAxis value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  calibrationStepNbXAxis;

	//	Try to initialize CalibrationStepNbYAxis from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  calibrationStepNbYAxis;
	else {
		//	Try to initialize CalibrationStepNbYAxis from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  calibrationStepNbYAxis;
	}
	//	And try to extract CalibrationStepNbYAxis value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  calibrationStepNbYAxis;

	//	Try to initialize XPIDDefinition from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  xPIDDefinition;
	else {
		//	Try to initialize XPIDDefinition from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  xPIDDefinition;
	}
	//	And try to extract XPIDDefinition value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  xPIDDefinition;

	//	Try to initialize YPIDDefinition from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  yPIDDefinition;
	else {
		//	Try to initialize YPIDDefinition from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  yPIDDefinition;
	}
	//	And try to extract YPIDDefinition value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  yPIDDefinition;

	//	Try to initialize DeviceMode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  deviceMode;
	else {
		//	Try to initialize DeviceMode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  deviceMode;
	}
	//	And try to extract DeviceMode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  deviceMode;

	//	Try to initialize FixedXTarget from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fixedXTarget;
	else {
		//	Try to initialize FixedXTarget from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fixedXTarget;
	}
	//	And try to extract FixedXTarget value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fixedXTarget;

	//	Try to initialize FixedYTarget from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fixedYTarget;
	else {
		//	Try to initialize FixedYTarget from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fixedYTarget;
	}
	//	And try to extract FixedYTarget value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fixedYTarget;

	//	Try to initialize FixedMode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fixedMode;
	else {
		//	Try to initialize FixedMode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fixedMode;
	}
	//	And try to extract FixedMode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fixedMode;

	//	Try to initialize FixedXWarningZoneCenter from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fixedXWarningZoneCenter;
	else {
		//	Try to initialize FixedXWarningZoneCenter from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fixedXWarningZoneCenter;
	}
	//	And try to extract FixedXWarningZoneCenter value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fixedXWarningZoneCenter;

	//	Try to initialize FixedYWarningZoneCenter from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fixedYWarningZoneCenter;
	else {
		//	Try to initialize FixedYWarningZoneCenter from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fixedYWarningZoneCenter;
	}
	//	And try to extract FixedYWarningZoneCenter value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fixedYWarningZoneCenter;

	//	Try to initialize FixedWarningZoneRadius from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fixedWarningZoneRadius;
	else {
		//	Try to initialize FixedWarningZoneRadius from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fixedWarningZoneRadius;
	}
	//	And try to extract FixedWarningZoneRadius value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fixedWarningZoneRadius;

	//	Try to initialize AxesAliases from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  axesAliases;
	else {
		//	Try to initialize AxesAliases from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  axesAliases;
	}
	//	And try to extract AxesAliases value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  axesAliases;

	//	Try to initialize UI_xColdThreshold from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  uI_xColdThreshold;
	else {
		//	Try to initialize UI_xColdThreshold from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  uI_xColdThreshold;
	}
	//	And try to extract UI_xColdThreshold value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  uI_xColdThreshold;

	//	Try to initialize UI_xHotThreshold from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  uI_xHotThreshold;
	else {
		//	Try to initialize UI_xHotThreshold from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  uI_xHotThreshold;
	}
	//	And try to extract UI_xHotThreshold value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  uI_xHotThreshold;

	//	Try to initialize UI_yHotThreshold from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  uI_yHotThreshold;
	else {
		//	Try to initialize UI_yHotThreshold from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  uI_yHotThreshold;
	}
	//	And try to extract UI_yHotThreshold value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  uI_yHotThreshold;

	//	Try to initialize UI_yColdThreshold from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  uI_yColdThreshold;
	else {
		//	Try to initialize UI_yColdThreshold from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  uI_yColdThreshold;
	}
	//	And try to extract UI_yColdThreshold value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  uI_yColdThreshold;



	//	End of Automatic code generation
	//------------------------------------------------------------------
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "1000", "DeviceTaskPeriod");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "10", "NbImgToAlign");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "pluginType", "SensorPluginType");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "actuator/syst/adrr", "ActuatorSystemDeviceAdress");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "plugin/path", "PluginPath");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "10", "CalibrationStepNbXAxis");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "10", "CalibrationStepNbYAxis");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "false::1::2::3", "XPIDDefinition");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "false::1::2::3", "YPIDDefinition");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "SIMULATED", "DeviceMode");

	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "false", "FixedMode");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "512", "FixedXTarget");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "512", "FixedYTarget");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "512", "FixedXWarningZoneCenter");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "512", "FixedYWarningZoneCenter");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "1", "FixedWarningZoneRadius");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "axeX\naxeY\n", "AxesAliases");

	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "5", "UI_xColdThreshold");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "5", "UI_yColdThreshold");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "2", "UI_xHotThreshold");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "2", "UI_yHotThreshold");

}
//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::always_executed_hook()
{
	if(m_initDone){
		if (m_taskManager){
			// Get task State and Status
			BPTTaskManager::StateStatus stateAndStatus = m_taskManager->i_getStateStatus();
			// Get task beam data 
			BPTTaskManager::ManagerDataPacket managerDataPacket = m_taskManager->i_getManagerDataPacket();
			// Update attributs values 
			m_xBeamPosition = managerDataPacket.beamDiagnostic.xBeamPosition;
			m_yBeamPosition = managerDataPacket.beamDiagnostic.yBeamPosition;
			m_computedTime = managerDataPacket.computedTime;

			m_imageHeight = managerDataPacket.beamDiagnostic.imgHeight;
			m_imageWidth = managerDataPacket.beamDiagnostic.imgWidth;
			m_thresholdedImage.clear();
			m_thresholdedImage = managerDataPacket.beamDiagnostic.thresholdedImg;

			m_xAxisRegulationThreshold = managerDataPacket.xAxisData.axisThreshold;
			m_yAxisRegulationThreshold = managerDataPacket.yAxisData.axisThreshold;

			set_state(stateAndStatus.state);
			set_status(stateAndStatus.status);
		}
	}	
}
//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "BeamPositionTracking::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
		
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_fixedMode
// 
// description : 	Extract real attribute values for fixedMode acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_fixedMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_fixedMode(Tango::Attribute &attr) entering... "<< endl;
	attr.set_value(&fixedMode);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_xAxisRegulationThreshold
// 
// description : 	Extract real attribute values for xAxisRegulationThreshold acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_xAxisRegulationThreshold(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_xAxisRegulationThreshold(Tango::Attribute &attr) entering... "<< endl;


	attr.set_value(&m_xAxisRegulationThreshold);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::write_xAxisRegulationThreshold
// 
// description : 	Write xAxisRegulationThreshold attribute values to hardware.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::write_xAxisRegulationThreshold(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::write_xAxisRegulationThreshold(Tango::WAttribute &attr) entering... "<< endl;

	ushort tmpXAxisThreshold;

	attr.get_write_value(tmpXAxisThreshold);
	if(m_initDone)
		if(m_taskManager)
			m_taskManager->i_setXAxisRegThreshold(tmpXAxisThreshold);

}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_yAxisRegulationThreshold
// 
// description : 	Extract real attribute values for yAxisRegulationThreshold acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_yAxisRegulationThreshold(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_yAxisRegulationThreshold(Tango::Attribute &attr) entering... "<< endl;
	attr.set_value(&m_yAxisRegulationThreshold);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::write_yAxisRegulationThreshold
// 
// description : 	Write yAxisRegulationThreshold attribute values to hardware.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::write_yAxisRegulationThreshold(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::write_yAxisRegulationThreshold(Tango::WAttribute &attr) entering... "<< endl;
	
	ushort tmpYAxisThreshold;

	attr.get_write_value(tmpYAxisThreshold);
	if(m_initDone)
		if(m_taskManager)
			m_taskManager->i_setYAxisRegThreshold(tmpYAxisThreshold);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_thresholdedImage
// 
// description : 	Extract real attribute values for thresholdedImage acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_thresholdedImage(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_thresholdedImage(Tango::Attribute &attr) entering... "<< endl;
	Tango::DevUChar* bufferAttr;

	bufferAttr = &m_thresholdedImage[0];
	attr.set_value(bufferAttr, m_imageWidth, m_imageHeight);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::readm_computedTime
// 
// description : 	Extract real attribute values for computedTime acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_computedTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::readm_computedTime(Tango::Attribute &attr) entering... "<< endl;
	attr.set_value(&m_computedTime);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_xAxisTarget
// 
// description : 	Extract real attribute values for xAxisTarget acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_xAxisTarget(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_xAxisTarget(Tango::Attribute &attr) entering... "<< endl;
	
	if (!fixedMode)
		attr.set_value(&m_target.xTargetPoint);
	else
		attr.set_value(&m_fixedModeDef.target.xTargetPoint);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::write_xAxisTarget
// 
// description : 	Write xAxisTarget attribute values to hardware.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::write_xAxisTarget(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::write_xAxisTarget(Tango::WAttribute &attr) entering... "<< endl;

  	if(m_initDone){
  		//Only if there is no fixed mode
		if (!fixedMode){
			Tango::DevShort xTarget;
		  	attr.get_write_value(xTarget);
		  	m_target.xTargetPoint = (short) xTarget;
		  	//Send value to the manager
			if (m_taskManager)
				m_taskManager->i_setTrackingTarget(m_target);	
		}
		else{
			THROW_DEVFAILED(
	        _CPTC("Wrong device mode"), 
	        _CPTC("Cannot write x Axis target in fixed mode \nSet value on property : FixedXTarget"),
	        _CPTC("BeamPositionTracking::write_xAxisTarget()")); 
		}
	}
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_yAxisTarget
// 
// description : 	Extract real attribute values for yAxisTarget acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_yAxisTarget(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_yAxisTarget(Tango::Attribute &attr) entering... "<< endl;

	if (!fixedMode)
		attr.set_value(&m_target.yTargetPoint);
	else
		attr.set_value(&m_fixedModeDef.target.yTargetPoint);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::write_yAxisTarget
// 
// description : 	Write yAxisTarget attribute values to hardware.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::write_yAxisTarget(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::write_yAxisTarget(Tango::WAttribute &attr) entering... "<< endl;

  	if(m_initDone){
  		//Only if there is no fixed mode
		if (!fixedMode){
			Tango::DevShort yTarget;
  			attr.get_write_value(yTarget);
  			m_target.yTargetPoint = (short) yTarget;
  			//Send value to the manager
			if (m_taskManager){
				m_taskManager->i_setTrackingTarget(m_target);
			}
		}
		else{
			THROW_DEVFAILED(
	       	_CPTC("Wrong device mode"), 
	        _CPTC("Cannot write y Axis target in fixed mode \nSet value on property : FixedYTarget"),
	        _CPTC("BeamPositionTracking::write_yAxisTarget()")); 
		}
	}

}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_xAxisCurrentBeamPosition
// 
// description : 	Extract real attribute values for xAxisCurrentBeamPosition acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_xAxisCurrentBeamPosition(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_xAxisCurrentBeamPosition(Tango::Attribute &attr) entering... "<< endl;
	attr.set_value(&m_xBeamPosition);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_yAxisCurrentBeamPosition
// 
// description : 	Extract real attribute values for yAxisCurrentBeamPosition acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_yAxisCurrentBeamPosition(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_yAxisCurrentBeamPosition(Tango::Attribute &attr) entering... "<< endl;
	attr.set_value(&m_yBeamPosition);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_warningZoneXCenter
// 
// description : 	Extract real attribute values for warningZoneXCenter acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_warningZoneXCenter(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_warningZoneXCenter(Tango::Attribute &attr) entering... "<< endl;

	if (!fixedMode)
		attr.set_value(&m_warningZone.xCenter);
	else 
		attr.set_value(&m_fixedModeDef.warningZone.xCenter);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::write_warningZoneXCenter
// 
// description : 	Write warningZoneXCenter attribute values to hardware.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::write_warningZoneXCenter(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::write_warningZoneXCenter(Tango::WAttribute &attr) entering... "<< endl;
	
	if(m_initDone){
  		//Only if there is no fixed mode
		if (!fixedMode){
			Tango::DevDouble xWarningZone;
		  	attr.get_write_value(xWarningZone);
			m_warningZone.xCenter = (double) xWarningZone;
  			//Send value to the manager
			if (m_taskManager){
				m_taskManager->i_setWarningZone(m_warningZone);
			}
		}else{
			THROW_DEVFAILED(
	       	_CPTC("Wrong device mode"), 
	        _CPTC("Cannot write X warning zone center in fixed mode \nSet value on property : FixedXWarningZoneCenter"),
	        _CPTC("BeamPositionTracking::write_warningZoneXCenter()")); 
		}

	}
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_warningZoneYCenter
// 
// description : 	Extract real attribute values for warningZoneYCenter acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_warningZoneYCenter(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_warningZoneYCenter(Tango::Attribute &attr) entering... "<< endl;

	if (!fixedMode)
		attr.set_value(&m_warningZone.yCenter);
	else 
		attr.set_value(&m_fixedModeDef.warningZone.yCenter);

}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::write_warningZoneYCenter
// 
// description : 	Write warningZoneYCenter attribute values to hardware.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::write_warningZoneYCenter(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::write_warningZoneYCenter(Tango::WAttribute &attr) entering... "<< endl;

	if(m_initDone){
  		//Only if there is no fixed mode
		if (!fixedMode){
			Tango::DevDouble yWarningZone;
		  	attr.get_write_value(yWarningZone);
			m_warningZone.yCenter = (double) yWarningZone;
			//Send value to the manager
			if (m_taskManager){
				m_taskManager->i_setWarningZone(m_warningZone);
			}
		}else{
			THROW_DEVFAILED(
	       	_CPTC("Wrong device mode"), 
	        _CPTC("Cannot write Y warning zone center in fixed mode \nSet value on property : FixedYWarningZoneCenter"),
	        _CPTC("BeamPositionTracking::write_warningZoneYCenter()")); 
		}
	}
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_warningZoneRadius
// 
// description : 	Extract real attribute values for warningZoneRadius acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_warningZoneRadius(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_warningZoneRadius(Tango::Attribute &attr) entering... "<< endl;

	if (!fixedMode)
		attr.set_value(&m_warningZone.radius);
	else 
		attr.set_value(&m_fixedModeDef.warningZone.radius);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::write_warningZoneRadius
// 
// description : 	Write warningZoneRadius attribute values to hardware.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::write_warningZoneRadius(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::write_warningZoneRadius(Tango::WAttribute &attr) entering... "<< endl;

	if(m_initDone){
  		//Only if there is no fixed mode
		if (!fixedMode){
			Tango::DevDouble radius;
		  	attr.get_write_value(radius);
			m_warningZone.radius = (double) radius;
			//Send value to the manager
			if (m_taskManager){
				m_taskManager->i_setWarningZone(m_warningZone);
			}
		}else{
			THROW_DEVFAILED(
	       	_CPTC("Wrong device mode"), 
	        _CPTC("Cannot write warning zone radius in fixed mode \nSet value on property : FixedWarningZoneRadius"),
	        _CPTC("BeamPositionTracking::write_warningZoneRadius()")); 
		}
	}
}

//+------------------------------------------------------------------
/**
 *	method:	BeamPositionTracking::actuator_system_calibration
 *
 *	description:	method to execute "ActuatorSystemCalibration"
 *	Will estimate new ratio on X and Y axes (only if axes are in a linear mode).
 *	To do so, it will record current beam centroid, move each axes with CalibrationStepNbX/YAxis value (set in properties) and record new centroid...
 *	This feature will then write linear new ratios on actuator system device.
 *
 *
 */
//+------------------------------------------------------------------
void BeamPositionTracking::actuator_system_calibration()
{
	DEBUG_STREAM << "BeamPositionTracking::actuator_system_calibration(): entering... !" << endl;
	try{
		if(m_initDone){
			if (m_taskManager){
				m_taskManager->i_runSystemCalibration();
			}
		}
	}catch(Tango::DevFailed &df){
		 RETHROW_DEVFAILED(df, "", "", "");
	}
}

//+------------------------------------------------------------------
/**
 *	method:	BeamPositionTracking::start_beam_tracking
 *
 *	description:	method to execute "StartBeamTracking"
 *	Will start beam tracking on target
 *
 *
 */
//+------------------------------------------------------------------
void BeamPositionTracking::start_beam_tracking()
{
	DEBUG_STREAM << "BeamPositionTracking::start_beam_tracking(): entering... !" << endl;
	try{
		if(m_initDone){
			if (m_taskManager){
				m_taskManager->i_turnTrackingModeOn(m_target);
			}
		}
	}catch(Tango::DevFailed &df){
		 RETHROW_DEVFAILED(df, "", "", "");
	}

}

//+------------------------------------------------------------------
/**
 *	method:	BeamPositionTracking::stop_beam_tracking
 *
 *	description:	method to execute "StopBeamTracking"
 *	Will stop beam tracking
 *
 *
 */
//+------------------------------------------------------------------
void BeamPositionTracking::stop_beam_tracking()
{
	DEBUG_STREAM << "BeamPositionTracking::stop_beam_tracking(): entering... !" << endl;
	if(m_initDone){
		if (m_taskManager){
			m_taskManager->i_turnTrackingModeOff();
		}
	}
}

BPTTaskManager::PIDCoefficient BeamPositionTracking::extractPIDCoeffients(std::string property) throw (std::invalid_argument){

    yat::StringTokenizer st(property, kTOKEN_SEPARATOR);
    string pidOnXInUse = st.next_token();
	BPTTaskManager::PIDCoefficient PIDToReturn;
	if(pidOnXInUse == "true"){
		PIDToReturn.isPIDEnabled = true;

	    PIDToReturn.P = std::stod(st.next_token(),0);
	    PIDToReturn.I = std::stod(st.next_token(),0);
		PIDToReturn.D = std::stod(st.next_token(),0);
	}else{
		PIDToReturn.isPIDEnabled = false;
		PIDToReturn.P =  0;
	    PIDToReturn.I =  0;
		PIDToReturn.D =  0;
	}
	return PIDToReturn;
}
//+------------------------------------------------------------------
/**
 *	method:	BeamPositionTracking::extractPIDCoeffients
 *
 *	description:	to init m_fixedModeDef using properties
 *
 */
//+------------------------------------------------------------------
bool BeamPositionTracking::initFixedModeValues(){
	m_fixedModeDef.isFixedModeEnabled = fixedMode;
	m_fixedModeDef.warningZone.xCenter = fixedXWarningZoneCenter;
	m_fixedModeDef.warningZone.yCenter = fixedYWarningZoneCenter;
	m_fixedModeDef.warningZone.radius = fixedWarningZoneRadius;
	m_fixedModeDef.target.xTargetPoint = fixedXTarget;
	m_fixedModeDef.target.yTargetPoint = fixedYTarget;
	//if fixed mode is enabled, need to check values.. otherwise, do nothing
	if(m_fixedModeDef.isFixedModeEnabled){
		if ((m_fixedModeDef.warningZone.xCenter < 0) || (m_fixedModeDef.warningZone.yCenter < 0))
			return false;
		if (m_fixedModeDef.warningZone.radius < 0)
			return false;
		if ((m_fixedModeDef.target.xTargetPoint < 0) || (m_fixedModeDef.target.yTargetPoint < 0))
			return false;
	}
	return true;
}
//+------------------------------------------------------------------
/**
 *	method:	setNewLabels(std::string xAlias, std::string yAlias)
 *
 */
//+------------------------------------------------------------------
void BeamPositionTracking::setNewLabels(std::string xAlias, std::string yAlias){
	
	updateAttrLabel("xAxisTarget", xAlias + " target");
	updateAttrLabel("yAxisTarget", yAlias + " target");
	updateAttrLabel("xAxisCurrentBeamPosition", xAlias + " Current Beam Position");
	updateAttrLabel("yAxisCurrentBeamPosition", yAlias + " Current Beam Position");
	updateAttrLabel("warningZoneXCenter", "Warning zone center on" + xAlias );
	updateAttrLabel("warningZoneYCenter", "Warning zone center on " + yAlias );
	updateAttrLabel("xAxisRegulationThreshold", xAlias + " Regulation Threshold");
	updateAttrLabel("yAxisRegulationThreshold", yAlias + " Regulation Threshold");

}
//+------------------------------------------------------------------
/**
 *	method:	updateAttrLabel(std::string attrName, std::string label)
 *
 */
//+------------------------------------------------------------------
void BeamPositionTracking::updateAttrLabel(std::string attrName, std::string newLabel){
	vector<string> vecattribute;
	vecattribute.push_back(attrName);

	Tango::DevVarStringArray dvsa_attribute;
	dvsa_attribute << vecattribute;

	Tango::AttributeConfigList* seq_conf;
	seq_conf = get_attribute_config(dvsa_attribute);
	(*seq_conf)[0].label   = newLabel.c_str();
	set_attribute_config((*seq_conf));
}

//+------------------------------------------------------------------
/**
 *	method:	BeamPositionTracking::acknowlege_step
 *
 *	description:	method to execute "AcknowlegeStep"
 *	Use in simulated mode only when tracking is running, to go to the next step
 *
 *
 */
//+------------------------------------------------------------------
void BeamPositionTracking::acknowlege_step()
{
	DEBUG_STREAM << "BeamPositionTracking::acknowlege_step(): entering... !" << endl;
	try{
		if(m_initDone){
			if (m_taskManager){
				m_taskManager->i_acknowlegeStep();
			}
		}
	}catch(...){
	}
}


}	//	namespace
