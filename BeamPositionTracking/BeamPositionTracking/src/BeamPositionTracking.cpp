static const char *RcsId = "$Id:  $";
//+=============================================================================
//
// file :         BeamPositionTracking.cpp
//
// description :  C++ source for the BeamPositionTracking and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                BeamPositionTracking are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source:  $
// $Log:  $
//
// copyleft :    Synchrotron SOLEIL 
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name               |  Method name
//	----------------------------------------
//  State                      |  dev_state()
//  Status                     |  dev_status()
//  ActuatorSystemCalibration  |  actuator_system_calibration()
//  StartBeamTracking          |  start_beam_tracking()
//  StopBeamTracking           |  stop_beam_tracking()
//  AcknowlegeStep             |  acknowlege_step()
//
//===================================================================


#include <tango.h>
#include <BeamPositionTracking.h>
#include <BeamPositionTrackingClass.h>
#include <yat/utils/StringTokenizer.h>

// Token separator for PS property.
#define kTOKEN_SEPARATOR std::string("::")
//Simulated mode strings
#define SIMULATED_MODE std::string("SIMULATED")
#define NORMAL_MODE std::string("NORMAL")
namespace BeamPositionTracking_ns
{

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::BeamPositionTracking(string &s)
// 
// description : 	constructor for simulated BeamPositionTracking
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
BeamPositionTracking::BeamPositionTracking(Tango::DeviceClass *cl,string &s)
:Tango::Device_4Impl(cl,s.c_str())
{
	init_device();
}

BeamPositionTracking::BeamPositionTracking(Tango::DeviceClass *cl,const char *s)
:Tango::Device_4Impl(cl,s)
{
	init_device();
}

BeamPositionTracking::BeamPositionTracking(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_4Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::delete_device()
{
	//	Delete device allocated objects
	if (m_taskManager)
		delete m_taskManager;
	if (m_dynAttrManager)
		delete m_dynAttrManager;

	//- remove the DeviceInfo
   // yat4tango::DeviceInfo::release(this);
    //- remove the InnerAppender
   // yat4tango::InnerAppender::release(this);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::init_device()
{
	INFO_STREAM << "BeamPositionTracking::BeamPositionTracking() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	get_device_property();

	// Initialize Members
	m_initDone = false;
	m_computedTime = 0;
	m_taskManager = 0;
	m_dynAttrManager = 0;
	m_xBeamPositionInPixels = 0;
	m_yBeamPositionInPixels = 0;
	
	BPTTaskManager::PIDCoefficient xAxisPID;
	BPTTaskManager::PIDCoefficient yAxisPID;

	INFO_STREAM << "Create the InnerAppender in order to manage logs." << endl;
   	// yat4tango::InnerAppender::initialize(this, 512);

	INFO_STREAM << "Create the DeviceInfo in order to manage info on versions." << endl;
   	// yat4tango::DeviceInfo::initialize( this, YAT_XSTR(PROJECT_NAME), YAT_XSTR(PROJECT_VERSION));
    // yat4tango::DeviceInfo::add_dependency(this, "BeamPositionTracking ", YAT_XSTR(beamPositionPointing_PROJECT_VERSION));


	bool simulated_mode = false;
	//Simulated mode 
	if (deviceMode == NORMAL_MODE)
		simulated_mode = false;
	else
		simulated_mode = true;

	//Extract PIDs informations
	try{
		xAxisPID = extractPIDCoeffients(xPIDDefinition);
		yAxisPID = extractPIDCoeffients(yPIDDefinition);
	}catch(std::invalid_argument &iaE){
        set_status ("Initialization error [PID definition not correct, has to be written this way : 'true::1::2::3']");
        set_state (Tango::FAULT);
        return;
	}

	//Construct fix mode instructions using properties
	if (!initFixModeValues()){
		std::string err_msg = "Initialization error [Check fix mode values or set fix mode to false]";
        ERROR_STREAM << err_msg << std::endl;
        set_status (err_msg);
        set_state (Tango::FAULT);
        return;
	}else{
		//init target and warning zone with fix definitions 
		m_target.xTargetPoint = m_fixModeDef.target.xTargetPoint;
		m_target.yTargetPoint = m_fixModeDef.target.yTargetPoint;
		m_warningZone.xCenter = m_fixModeDef.warningZone.xCenter;
		m_warningZone.yCenter = m_fixModeDef.warningZone.yCenter;
		m_warningZone.radius = m_fixModeDef.warningZone.radius;
	}
	
	// Creation of dynAttrManager
	try{
		if (!m_dynAttrManager)
			m_dynAttrManager = new yat4tango::DynamicAttributeManager(this);

	}catch( Tango::DevFailed& df ){
        ERROR_STREAM << df << std::endl;
        set_status ("Initialization error [Tango Exception caught while instantiating DynamicAttributeManager]");
        set_state (Tango::FAULT);
        return;
    }
    catch(...){
        std::string err_msg = "Initialization error [unknown exception caught while instantiating DynamicAttributeManager]";
        ERROR_STREAM << err_msg << std::endl;
        set_status (err_msg);
        set_state (Tango::FAULT);
        return;
    }

	// Creation of BPTTaskManager
	try{
		if (!m_taskManager)
			m_taskManager = new BPTTaskManager::BPTTaskManager(this, m_dynAttrManager, sensorPluginType, pluginPath, 
																	actuatorSystemDeviceAdress,
																	xAxisPID, yAxisPID,
																	calibrationStepNbXAxis, calibrationStepNbYAxis,
																	nbImgToAlign, deviceTaskPeriod, simulated_mode, m_fixModeDef);


		//Init plug with attr in this thread.... since it's possible that the plugin has an attribute ???
		if (!m_taskManager->sensorPluginInitialisation()){
			set_status ("Initialization error [Tango Exception caught while instantiating BPTTaskManager]");
	        set_state (Tango::FAULT);
	        return;
		}


	}catch( Tango::DevFailed &df ){
        ERROR_STREAM << df << std::endl;
        set_status ("Initialization error [Tango Exception caught while instantiating BPTTaskManager]");
        set_state (Tango::FAULT);
        return;
    }
    catch(...){
        std::string err_msg = "Initialization error [unknown exception caught while instantiating BPTTaskManager]";
        ERROR_STREAM << err_msg << std::endl;
        set_status (err_msg);
        set_state (Tango::FAULT);
        return;
    }

    // Start BPTTaskManager
    try
    {
        if (m_taskManager)
			m_taskManager->go(3000);
		
        set_state(Tango::INIT);
        set_status("Device initialisation started...");
    }
    catch( Tango::DevFailed &df )
    {
        ERROR_STREAM << df << std::endl;
        set_status ("Initialization error [Tango Error: " +  std::string(df.errors[0].desc) + ", while starting BPTTaskManager]");
        set_state (Tango::FAULT);
        m_taskManager = NULL;
        return;
    }
    catch(...)
    {
        std::string err_msg = "Initialization error [Unknown Error while starting BPTTaskManager]";  
        ERROR_STREAM << err_msg << std::endl;
        set_status (err_msg);
        set_state (Tango::FAULT);
        m_taskManager = NULL;
        return;
    }

    m_initDone = true;
}


//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("DeviceTaskPeriod"));
	dev_prop.push_back(Tango::DbDatum("NbImgToAlign"));
	dev_prop.push_back(Tango::DbDatum("SensorPluginType"));
	dev_prop.push_back(Tango::DbDatum("ActuatorSystemDeviceAdress"));
	dev_prop.push_back(Tango::DbDatum("PluginPath"));
	dev_prop.push_back(Tango::DbDatum("CalibrationStepNbXAxis"));
	dev_prop.push_back(Tango::DbDatum("CalibrationStepNbYAxis"));
	dev_prop.push_back(Tango::DbDatum("XPIDDefinition"));
	dev_prop.push_back(Tango::DbDatum("YPIDDefinition"));
	dev_prop.push_back(Tango::DbDatum("DeviceMode"));
	dev_prop.push_back(Tango::DbDatum("FixXTarget"));
	dev_prop.push_back(Tango::DbDatum("FixYTarget"));
	dev_prop.push_back(Tango::DbDatum("FixMode"));
	dev_prop.push_back(Tango::DbDatum("FixXWarningZoneCenter"));
	dev_prop.push_back(Tango::DbDatum("FixYWarningZoneCenter"));
	dev_prop.push_back(Tango::DbDatum("FixWarningZoneRadius"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	BeamPositionTrackingClass	*ds_class =
		(static_cast<BeamPositionTrackingClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize DeviceTaskPeriod from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  deviceTaskPeriod;
	else {
		//	Try to initialize DeviceTaskPeriod from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  deviceTaskPeriod;
	}
	//	And try to extract DeviceTaskPeriod value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  deviceTaskPeriod;

	//	Try to initialize NbImgToAlign from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  nbImgToAlign;
	else {
		//	Try to initialize NbImgToAlign from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  nbImgToAlign;
	}
	//	And try to extract NbImgToAlign value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  nbImgToAlign;

	//	Try to initialize SensorPluginType from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sensorPluginType;
	else {
		//	Try to initialize SensorPluginType from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sensorPluginType;
	}
	//	And try to extract SensorPluginType value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sensorPluginType;

	//	Try to initialize ActuatorSystemDeviceAdress from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  actuatorSystemDeviceAdress;
	else {
		//	Try to initialize ActuatorSystemDeviceAdress from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  actuatorSystemDeviceAdress;
	}
	//	And try to extract ActuatorSystemDeviceAdress value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  actuatorSystemDeviceAdress;

	//	Try to initialize PluginPath from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  pluginPath;
	else {
		//	Try to initialize PluginPath from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  pluginPath;
	}
	//	And try to extract PluginPath value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pluginPath;

	//	Try to initialize CalibrationStepNbXAxis from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  calibrationStepNbXAxis;
	else {
		//	Try to initialize CalibrationStepNbXAxis from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  calibrationStepNbXAxis;
	}
	//	And try to extract CalibrationStepNbXAxis value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  calibrationStepNbXAxis;

	//	Try to initialize CalibrationStepNbYAxis from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  calibrationStepNbYAxis;
	else {
		//	Try to initialize CalibrationStepNbYAxis from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  calibrationStepNbYAxis;
	}
	//	And try to extract CalibrationStepNbYAxis value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  calibrationStepNbYAxis;

	//	Try to initialize XPIDDefinition from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  xPIDDefinition;
	else {
		//	Try to initialize XPIDDefinition from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  xPIDDefinition;
	}
	//	And try to extract XPIDDefinition value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  xPIDDefinition;

	//	Try to initialize YPIDDefinition from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  yPIDDefinition;
	else {
		//	Try to initialize YPIDDefinition from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  yPIDDefinition;
	}
	//	And try to extract YPIDDefinition value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  yPIDDefinition;

	//	Try to initialize DeviceMode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  deviceMode;
	else {
		//	Try to initialize DeviceMode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  deviceMode;
	}
	//	And try to extract DeviceMode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  deviceMode;

	//	Try to initialize FixXTarget from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fixXTarget;
	else {
		//	Try to initialize FixXTarget from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fixXTarget;
	}
	//	And try to extract FixXTarget value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fixXTarget;

	//	Try to initialize FixYTarget from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fixYTarget;
	else {
		//	Try to initialize FixYTarget from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fixYTarget;
	}
	//	And try to extract FixYTarget value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fixYTarget;

	//	Try to initialize FixMode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fixMode;
	else {
		//	Try to initialize FixMode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fixMode;
	}
	//	And try to extract FixMode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fixMode;

	//	Try to initialize FixXWarningZoneCenter from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fixXWarningZoneCenter;
	else {
		//	Try to initialize FixXWarningZoneCenter from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fixXWarningZoneCenter;
	}
	//	And try to extract FixXWarningZoneCenter value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fixXWarningZoneCenter;

	//	Try to initialize FixYWarningZoneCenter from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fixYWarningZoneCenter;
	else {
		//	Try to initialize FixYWarningZoneCenter from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fixYWarningZoneCenter;
	}
	//	And try to extract FixYWarningZoneCenter value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fixYWarningZoneCenter;

	//	Try to initialize FixWarningZoneRadius from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fixWarningZoneRadius;
	else {
		//	Try to initialize FixWarningZoneRadius from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fixWarningZoneRadius;
	}
	//	And try to extract FixWarningZoneRadius value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fixWarningZoneRadius;



	//	End of Automatic code generation
	//------------------------------------------------------------------
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "1000", "DeviceTaskPeriod");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "10", "NbImgToAlign");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "pluginType", "SensorPluginType");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "actuator/syst/adrr", "ActuatorSystemDeviceAdress");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "plugin/path", "PluginPath");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "10", "CalibrationStepNbXAxis");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "10", "CalibrationStepNbYAxis");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "false::1::2::3", "XPIDDefinition");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "false::1::2::3", "YPIDDefinition");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "SIMULATED", "DeviceMode");

	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "false", "FixMode");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "512", "FixXTarget");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "512", "FixYTarget");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "512", "FixXWarningZoneCenter");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "512", "FixYWarningZoneCenter");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "1", "FixWarningZoneRadius");


}
//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::always_executed_hook()
{
	if(m_initDone){
		if (m_taskManager){
			// Get task State and Status
			BPTTaskManager::StateStatus stateAndStatus = m_taskManager->i_getStateStatus();
			// Get task beam data 
			BPTTaskManager::ManagerDataPacket managerDataPacket = m_taskManager->i_getManagerDataPacket();
			// Update attributs values 
			m_xBeamPositionInPixels = (short)managerDataPacket.beamDiagnostic.xBeamPostionPixels;
			m_yBeamPositionInPixels = (short)managerDataPacket.beamDiagnostic.yBeamPostionPixels;
			m_computedTime = managerDataPacket.computedTime;

			m_imageHigh = managerDataPacket.beamDiagnostic.imgHigh;
			m_imageWidth = managerDataPacket.beamDiagnostic.imgWidth;
			m_thresholdedImage.clear();
			m_thresholdedImage = managerDataPacket.beamDiagnostic.tresholdedImg;

			m_xAxisRegulationThreshold = managerDataPacket.xAxisData.axisThreshold;
			m_yAxisRegulationThreshold = managerDataPacket.yAxisData.axisThreshold;

			set_state(stateAndStatus.state);
			set_status(stateAndStatus.status);
		}
	}	
}
//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "BeamPositionTracking::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
		
}
//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_fixMode
// 
// description : 	Extract real attribute values for fixMode acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_fixMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_fixMode(Tango::Attribute &attr) entering... "<< endl;
	attr.set_value(&fixMode);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_xAxisRegulationThreshold
// 
// description : 	Extract real attribute values for xAxisRegulationThreshold acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_xAxisRegulationThreshold(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_xAxisRegulationThreshold(Tango::Attribute &attr) entering... "<< endl;
	attr.set_value(&m_xAxisRegulationThreshold);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::write_xAxisRegulationThreshold
// 
// description : 	Write xAxisRegulationThreshold attribute values to hardware.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::write_xAxisRegulationThreshold(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::write_xAxisRegulationThreshold(Tango::WAttribute &attr) entering... "<< endl;
	
	ushort tmpXAxisThreshold;

	attr.get_write_value(tmpXAxisThreshold);
	if(m_initDone)
		if(m_taskManager)
			m_taskManager->i_setXAxisRegThreshold(tmpXAxisThreshold);

}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_yAxisRegulationThreshold
// 
// description : 	Extract real attribute values for yAxisRegulationThreshold acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_yAxisRegulationThreshold(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_yAxisRegulationThreshold(Tango::Attribute &attr) entering... "<< endl;
	attr.set_value(&m_yAxisRegulationThreshold);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::write_yAxisRegulationThreshold
// 
// description : 	Write yAxisRegulationThreshold attribute values to hardware.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::write_yAxisRegulationThreshold(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::write_yAxisRegulationThreshold(Tango::WAttribute &attr) entering... "<< endl;
	
	ushort tmpYAxisThreshold;

	attr.get_write_value(tmpYAxisThreshold);
	if(m_initDone)
		if(m_taskManager)
			m_taskManager->i_setYAxisRegThreshold(tmpYAxisThreshold);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_thresholdedImage
// 
// description : 	Extract real attribute values for thresholdedImage acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_thresholdedImage(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_thresholdedImage(Tango::Attribute &attr) entering... "<< endl;
	Tango::DevUChar* bufferAttr;

	bufferAttr = &m_thresholdedImage[0];
	attr.set_value(bufferAttr, m_imageWidth, m_imageHigh);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::readm_computedTime
// 
// description : 	Extract real attribute values for computedTime acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_computedTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::readm_computedTime(Tango::Attribute &attr) entering... "<< endl;
	attr.set_value(&m_computedTime);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_xAxisTarget
// 
// description : 	Extract real attribute values for xAxisTarget acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_xAxisTarget(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_xAxisTarget(Tango::Attribute &attr) entering... "<< endl;
	
	if (!fixMode)
		attr.set_value(&m_target.xTargetPoint);
	else
		attr.set_value(&m_fixModeDef.target.xTargetPoint);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::write_xAxisTarget
// 
// description : 	Write xAxisTarget attribute values to hardware.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::write_xAxisTarget(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::write_xAxisTarget(Tango::WAttribute &attr) entering... "<< endl;

  	if(m_initDone){
  		//Only if there is no fix mode
		if (!fixMode){
			Tango::DevShort xTarget;
		  	attr.get_write_value(xTarget);
		  	m_target.xTargetPoint = (short) xTarget;
		  	//Send value to the manager
			if (m_taskManager)
				m_taskManager->i_setTrackingTarget(m_target);	
		}
		else{
			THROW_DEVFAILED(
	        _CPTC("Wrong device mode"), 
	        _CPTC("Cannot write x Axis target in fix mode \nSet value on property : FixXTarget"),
	        _CPTC("BeamPositionTracking::write_xAxisTarget()")); 
		}
	}
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_yAxisTarget
// 
// description : 	Extract real attribute values for yAxisTarget acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_yAxisTarget(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_yAxisTarget(Tango::Attribute &attr) entering... "<< endl;

	if (!fixMode)
		attr.set_value(&m_target.yTargetPoint);
	else
		attr.set_value(&m_fixModeDef.target.yTargetPoint);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::write_yAxisTarget
// 
// description : 	Write yAxisTarget attribute values to hardware.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::write_yAxisTarget(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::write_yAxisTarget(Tango::WAttribute &attr) entering... "<< endl;

  	if(m_initDone){
  		//Only if there is no fix mode
		if (!fixMode){
			Tango::DevShort yTarget;
  			attr.get_write_value(yTarget);
  			m_target.yTargetPoint = (short) yTarget;
  			//Send value to the manager
			if (m_taskManager){
				m_taskManager->i_setTrackingTarget(m_target);
			}
		}
		else{
			THROW_DEVFAILED(
	       	_CPTC("Wrong device mode"), 
	        _CPTC("Cannot write y Axis target in fix mode \nSet value on property : FixYTarget"),
	        _CPTC("BeamPositionTracking::write_yAxisTarget()")); 
		}
	}

}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_xAxisCurrentBeamPosition
// 
// description : 	Extract real attribute values for xAxisCurrentBeamPosition acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_xAxisCurrentBeamPosition(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_xAxisCurrentBeamPosition(Tango::Attribute &attr) entering... "<< endl;
	attr.set_value(&m_xBeamPositionInPixels);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_yAxisCurrentBeamPosition
// 
// description : 	Extract real attribute values for yAxisCurrentBeamPosition acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_yAxisCurrentBeamPosition(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_yAxisCurrentBeamPosition(Tango::Attribute &attr) entering... "<< endl;
	attr.set_value(&m_yBeamPositionInPixels);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_warningZoneXCenter
// 
// description : 	Extract real attribute values for warningZoneXCenter acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_warningZoneXCenter(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_warningZoneXCenter(Tango::Attribute &attr) entering... "<< endl;

	if (!fixMode)
		attr.set_value(&m_warningZone.xCenter);
	else 
		attr.set_value(&m_fixModeDef.warningZone.xCenter);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::write_warningZoneXCenter
// 
// description : 	Write warningZoneXCenter attribute values to hardware.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::write_warningZoneXCenter(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::write_warningZoneXCenter(Tango::WAttribute &attr) entering... "<< endl;
	
	if(m_initDone){
  		//Only if there is no fix mode
		if (!fixMode){
			Tango::DevDouble xWarningZone;
		  	attr.get_write_value(xWarningZone);
			m_warningZone.xCenter = (double) xWarningZone;
  			//Send value to the manager
			if (m_taskManager){
				m_taskManager->i_setWarningZone(m_warningZone);
			}
		}else{
			THROW_DEVFAILED(
	       	_CPTC("Wrong device mode"), 
	        _CPTC("Cannot write X warning zone center in fix mode \nSet value on property : FixXWarningZoneCenter"),
	        _CPTC("BeamPositionTracking::write_warningZoneXCenter()")); 
		}

	}
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_warningZoneYCenter
// 
// description : 	Extract real attribute values for warningZoneYCenter acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_warningZoneYCenter(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_warningZoneYCenter(Tango::Attribute &attr) entering... "<< endl;

	if (!fixMode)
		attr.set_value(&m_warningZone.yCenter);
	else 
		attr.set_value(&m_fixModeDef.warningZone.yCenter);

}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::write_warningZoneYCenter
// 
// description : 	Write warningZoneYCenter attribute values to hardware.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::write_warningZoneYCenter(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::write_warningZoneYCenter(Tango::WAttribute &attr) entering... "<< endl;

	if(m_initDone){
  		//Only if there is no fix mode
		if (!fixMode){
			Tango::DevDouble yWarningZone;
		  	attr.get_write_value(yWarningZone);
			m_warningZone.yCenter = (double) yWarningZone;
			//Send value to the manager
			if (m_taskManager){
				m_taskManager->i_setWarningZone(m_warningZone);
			}
		}else{
			THROW_DEVFAILED(
	       	_CPTC("Wrong device mode"), 
	        _CPTC("Cannot write Y warning zone center in fix mode \nSet value on property : FixYWarningZoneCenter"),
	        _CPTC("BeamPositionTracking::write_warningZoneYCenter()")); 
		}
	}
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::read_warningZoneRadius
// 
// description : 	Extract real attribute values for warningZoneRadius acquisition result.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::read_warningZoneRadius(Tango::Attribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::read_warningZoneRadius(Tango::Attribute &attr) entering... "<< endl;

	if (!fixMode)
		attr.set_value(&m_warningZone.radius);
	else 
		attr.set_value(&m_fixModeDef.warningZone.radius);
}

//+----------------------------------------------------------------------------
//
// method : 		BeamPositionTracking::write_warningZoneRadius
// 
// description : 	Write warningZoneRadius attribute values to hardware.
//
//-----------------------------------------------------------------------------
void BeamPositionTracking::write_warningZoneRadius(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "BeamPositionTracking::write_warningZoneRadius(Tango::WAttribute &attr) entering... "<< endl;

	if(m_initDone){
  		//Only if there is no fix mode
		if (!fixMode){
			Tango::DevDouble radius;
		  	attr.get_write_value(radius);
			m_warningZone.radius = (double) radius;
			//Send value to the manager
			if (m_taskManager){
				m_taskManager->i_setWarningZone(m_warningZone);
			}
		}else{
			THROW_DEVFAILED(
	       	_CPTC("Wrong device mode"), 
	        _CPTC("Cannot write warning zone radius in fix mode \nSet value on property : FixWarningZoneRadius"),
	        _CPTC("BeamPositionTracking::write_warningZoneRadius()")); 
		}
	}
}

//+------------------------------------------------------------------
/**
 *	method:	BeamPositionTracking::actuator_system_calibration
 *
 *	description:	method to execute "ActuatorSystemCalibration"
 *	Will estimate new ratio on X and Y translation
 *
 *
 */
//+------------------------------------------------------------------
void BeamPositionTracking::actuator_system_calibration()
{
	DEBUG_STREAM << "BeamPositionTracking::actuator_system_calibration(): entering... !" << endl;
	try{
		if(m_initDone){
			if (m_taskManager){
				m_taskManager->i_runSystemCalibration();
			}
		}
	}catch(Tango::DevFailed &df){
		 RETHROW_DEVFAILED(df, "", "", "");
	}
}

//+------------------------------------------------------------------
/**
 *	method:	BeamPositionTracking::start_beam_tracking
 *
 *	description:	method to execute "StartBeamTracking"
 *
 *
 */
//+------------------------------------------------------------------
void BeamPositionTracking::start_beam_tracking()
{
	DEBUG_STREAM << "BeamPositionTracking::start_beam_tracking(): entering... !" << endl;
	try{
		if(m_initDone){
			if (m_taskManager){
				m_taskManager->i_turnTrackingModeOn(m_target);
			}
		}
	}catch(Tango::DevFailed &df){
		 RETHROW_DEVFAILED(df, "", "", "");
	}

}

//+------------------------------------------------------------------
/**
 *	method:	BeamPositionTracking::stop_beam_tracking
 *
 *	description:	method to execute "StopBeamTracking"
 *
 *
 */
//+------------------------------------------------------------------
void BeamPositionTracking::stop_beam_tracking()
{
	DEBUG_STREAM << "BeamPositionTracking::stop_beam_tracking(): entering... !" << endl;
	if(m_initDone){
		if (m_taskManager){
			m_taskManager->i_turnTrackingModeOff();
		}
	}
}

BPTTaskManager::PIDCoefficient BeamPositionTracking::extractPIDCoeffients(std::string property) throw (std::invalid_argument){

    yat::StringTokenizer st(property, kTOKEN_SEPARATOR);
    string pidOnXInUse = st.next_token();
	BPTTaskManager::PIDCoefficient PIDToReturn;
	if(pidOnXInUse == "true"){
		PIDToReturn.isPIDEnabled = true;

	    PIDToReturn.P = std::stod(st.next_token(),0);
	    PIDToReturn.I = std::stod(st.next_token(),0);
		PIDToReturn.D = std::stod(st.next_token(),0);
	}else{
		PIDToReturn.isPIDEnabled = false;
		PIDToReturn.P =  0;
	    PIDToReturn.I =  0;
		PIDToReturn.D =  0;
	}
	return PIDToReturn;
}
//+------------------------------------------------------------------
/**
 *	method:	BeamPositionTracking::extractPIDCoeffients
 *
 *	description:	to init m_fixModeDef using properties
 *
 */
//+------------------------------------------------------------------
bool BeamPositionTracking::initFixModeValues(){
	m_fixModeDef.isFixModeEnabled = fixMode;
	m_fixModeDef.warningZone.xCenter = fixXWarningZoneCenter;
	m_fixModeDef.warningZone.yCenter = fixYWarningZoneCenter;
	m_fixModeDef.warningZone.radius = fixWarningZoneRadius;
	m_fixModeDef.target.xTargetPoint = fixXTarget;
	m_fixModeDef.target.yTargetPoint = fixYTarget;
	//if fix mode is enabled, need to check values.. otherwise, do nothing
	if(m_fixModeDef.isFixModeEnabled){
		if ((m_fixModeDef.warningZone.xCenter < 0) || (m_fixModeDef.warningZone.yCenter < 0))
			return false;
		if (m_fixModeDef.warningZone.radius < 0)
			return false;
		if ((m_fixModeDef.target.xTargetPoint < 0) || (m_fixModeDef.target.yTargetPoint < 0))
			return false;
	}
	return true;
}
//+------------------------------------------------------------------
/**
 *	method:	BeamPositionTracking::acknowlege_step
 *
 *	description:	method to execute "AcknowlegeStep"
 *	Use this command in simulated mode
 *
 *
 */
//+------------------------------------------------------------------
void BeamPositionTracking::acknowlege_step()
{
	DEBUG_STREAM << "BeamPositionTracking::acknowlege_step(): entering... !" << endl;
	try{
		if(m_initDone){
			if (m_taskManager){
				m_taskManager->i_acknowlegeStep();
			}
		}
	}catch(...){
	}
}



}	//	namespace
